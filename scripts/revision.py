def verify_file_writable(filename):
    import os.path
    from pathlib import Path
    if os.path.exists(filename):
        if os.path.isfile(filename):
            return os.access(filename, os.W_OK)
        return False  # since this is a directory and not a file
    # the filename is not valid, ensure the directory exists
    parent = '.' if not os.path.dirname(filename) else os.path.dirname(filename)
    if not os.path.exists(parent):
        Path(parent).mkdir(parents=True)
    return os.access(parent, os.W_OK)


def verify_and_write(file, contents):
    if not verify_file_writable(file):
        raise RuntimeError('The file location {} is not writable!'.format(file))
    with open(file, 'w') as handle:
        handle.write(contents)


def call_and_return(command, onerror):
    from subprocess import check_output, CalledProcessError
    try:
        value = check_output(command).strip().decode('UTF-8')
    except (CalledProcessError, OSError):
        value = onerror
    return value


def version_info():
    git_revision = call_and_return('git describe --always --tags --dirty'.split(), 'unknown version')
    git_date = call_and_return(['git', 'log', '-1', '--format="%ad"', '--date=format:%B %d, %Y'], 'Never').strip('"')
    git_branch = call_and_return('git rev-parse --abbrev-ref HEAD'.split(), 'Not a repository')
    head, info = f'Revision: {git_revision}', f', {git_revision}'
    if 'final' in git_revision.lower():
        head, info = '', ''
    return git_branch, git_revision, git_date, head, info


TEX_CONTENTS = """% Automatically generated file:
% The contents of this file have been generated by revision.py.
% Any changes will be overwritten without warning.
%
\\newcommand{{\\revisionbranch}}{{{0:}}}
\\newcommand{{\\revision}}{{{1:}}}
\\newcommand{{\\revisiondate}}{{{2:}}}
\\newcommand{{\\revisionhead}}{{{3:}}}
\\newcommand{{\\revisiontail}}{{{4:}}}
"""

verify_and_write(snakemake.output[0], TEX_CONTENTS.format(*version_info()))
